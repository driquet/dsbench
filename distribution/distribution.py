'''
File: distribution.py
Author: Damien Riquet
Description: Skeleton of a distribution method
             Actual way to distribute attack is described using this abstract class

             Main methods are:
                * pre_experiment: initialize the distribution method,
                * run_experiment: run
                * post_experiment: create backup, etc.
'''

# Imports
import random
import xmlrpclib


class DistributionMethod():
    """ Distribution Method class
        Represents a way to distribute attacks
    """

    def __init__(self, logger, conf):
        """ Initialize a Distribution Method """
        # Attributes
        self._logger = logger
        self._conf = conf
        self._detected_scanners = []

        ## Attributes related to results 
        # Traffic contains traffic generated by scanners and receveived by targets
        self._traffic = {}
        self._traffic['scanners'] = {}
        self._traffic['targets'] = {}

        # Port state contains real port states of target hosts and port states found by scanners during portscan
        self._portstate = {}
        self._portstate['scanners'] = {}
        self._portstate['targets'] = {}


# ########## Main methods 

    def pre_experiment(self):
        """ Method called before a experiment is launched """
        # Init RPC proxies
        self.init_rpc_proxies()


    def run_experiment(self):
        """ Run the experiment using this distribution method 
            This method has to be implemented in inherited classes
        """
        pass


    def post_experiment(self):
        """ Process all action that has to be done after an experiment
            For example: compute the Attacker Success Rate, create back_up, etc.
        """
        # Compute results, including ASR
        self.compute_experiment_result()

        # Back up log files
        # TODO



# ########## Secondary methods 
    
    def init_rpc_proxies(self):
        """ Initialize scanner, firewall and target rpc proxies """
        self._p_scanners = {}
        self._p_firewalls = {}
        self._p_targets = {}

        # Scanner RPC proxies
        for host in self._conf['hosts']['scanners']:
            self._p_scanners[host['ip']] = xmlrpclib.ServerProxy("http://%s:%d/" % (host['ip'], host['port']))


        # Firewall RPC proxies
        for host in self._conf['hosts']['firewalls']:
            self._p_firewalls[host['ip']] = xmlrpclib.ServerProxy("http://%s:%d/" % (host['ip'], host['port']))


        # Target RPC proxies
        for host in self._conf['hosts']['targets']:
            self._p_targets[host['ip']] = xmlrpclib.ServerProxy("http://%s:%d/" % (host['ip'], host['port']))


    def compute_experiment_result(self):
        """ Compute result of this experimentation
            Result of an experiment is called Attacker Success Rate
            It is compute as follows :
                * n = Number of ports successfully scanned before detection
                * T = Total number of ports to be scanned
                * ASR = n / T
            A port is successfully scanned when:
                * port state has been well detected
                * traffic sent by scanner is received by targets
                * portscan has not been detected
        """
        # 0) Initialization
        n = 0
        port_per_host = len(conf['experiments']['ports']) 
        T = port_per_host * len(conf['hosts']['targets'])

        for target, ports in self._portstate['scanners'].items():
            # for each target, verify portscan executed by scanners
            local_counter = 0 # Represents the local (it means for this target) number of port successfully scanned
            
            for scanner, port, state in ports:
                # for each port scanned by a scanners, verify that it is successful

                # 1) Verify that the found state is the real one
                if self._portstate['targets'][target][port] != state:
                    self._logger.debug('Found a difference between found port state and real one : target %s - port is %d but found %s' \
                            % (target, self._portstate['targets'][target][port], state))
                    continue

                # 2) Verify that traffic generated by scanner has been well received by target
                for pkt in self._traffic['scanners'][scanner][target][port]:
                    # For each packet sent by a scanner, verify it has been received by the target
                    if pkt not in self._traffic['targets'][target][scanner][port]:
                        self._logger.debug('Generated traffic by scanner %s has not been received by %s (port %d)' \
                                % (scanner, target, port))
                        continue

                # 3) Verify scanner has not been detected
                # In fact, self._portstate['scanners'] contains only scanned scanner
                # As a scanner is stopped when a firewall has detected it, unscanned port are not in this structure

                # This port has been successfully scanned
                local_counter += 1
                n += 1

            self._logger.info("target %s - %d of %d ports scanned - %d of %d successfully scanned" \
                    % (target, len(ports), port_per_host, local_counter, len(ports))) 

        # Every portscan lead during this experimentation has been verified
        # Variable n contains the number of port successfully scanned
        # So we can compute the ASR
        ASR = float(n) / float(T)
        self._logger.info("Experiment results: %d of %d ports were successfully scanned - ASR - %f" \
                % (n, T, ASR))




# ########## OLDIES

    def generate(self, victims, ports, nbgroup=0):
        """ Generate subparts of the portscanning """
        subparts = []
        nbports = len(ports)
        if nbgroup == 0:
            portspergroup = 3
            nbgroup = nbports / portspergroup
        else:
            portspergroup = nbports / nbgroup
        for victim in victims:
            random.shuffle(ports, random.random)
            for i in range(0, nbgroup):
                subparts.append((victim,ports[i*portspergroup:(i+1)*portspergroup]))
            if nbports % portspergroup != 0:
                # Last subpart
                subparts.append((victim,ports[nbgroup*portspergroup+1:]))
        return subparts
